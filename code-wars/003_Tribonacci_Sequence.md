# Tribonacci Sequence

フィボナッチの兄貴分、トリボナッチと出会いました。

その名の通り、基本的にはフィボナッチと同じような働きをするのですが、数列の最後の3つ（2つではなく）を合計して次の数列を生成するのです。そして、残念なことに、イタリア語を母国語としない人たちの発音を聞くことができません :(

では、`[1, 1, 1]`を入力（別名サイン）としてトリボナッチ数列を始めるとすると、次のような数列ができあがります。

```
[1, 1 ,1, 3, 5, 9, 17, 31, ...]
```

しかし、`[0, 0, 1]`を署名として始めたらどうでしょうか？`[1, 1]`ではなく、`[0, 1]`から始めると、一般的なフィボナッチ数列が1位ずれるので、同じ数列を2位ずらして得られると考えたくなるかもしれませんが、そうではなく、次のような数列になります。

```
[0, 0, 1, 1, 2, 4, 7, 13, 24, ...]
```

さて、もうお分かりかと思いますが、はっきり言って、シグネチャ配列/リストが与えられたら、シードされた数列の最初のn個の要素（シグネチャも含む）を返すフィボナッチ関数を作成する必要があります。

シグネチャは常に3つの数を含み、`n`は常に非負の数です。もし`n==0`なら、空の配列を返し（Cではreturn NULLを除く）、明確に指定されていない他のものにも対応できるように準備してください ;)

この型を楽しんでいただけたなら、より高度で一般化されたバージョンがXbonacciの型にあります。


## 私の解答

```clojure
(ns kata)


(defn tribonacci [[a b c] n]
  (letfn [(f [x y z]
             (lazy-seq (cons x (f y z (+ x y z)))))]
    (take n (f a b c))))
```

